a) Herramientas
1. maven
	Conoces maven? como funciona y para que sirve?
	Como resuelvo un problema de dependencias con maven?
	Cuales son los scope de las dependencias de maven?

2. git
	2.1 Que es un branch?
	- 
	2.2 Estas en rama master, creas un branch llamado 'branch1', efectuas cambios en el,como son los pasos para que tus cambios se reflejen en master.
	- git add . ; git commit -m "asd" ; git push
	2.3 Como cambio un typo en un mensaje ya commiteado. 
	- git commit --amend
	3.4 Cherry picking.
	-
	3.5 Que es un pull request?
	-
	3.6 Diferencia entre fork, branch, clone.

3. Servidor de colas externos, activemq/kafka

4. Bamboo
	*para que sirve.
5. Jira 
	* conta un poco de tu expreiencia con jira
6. jenkins

7. cucumber

8. Gradle
	* Que es y para que sirve?
	* Ventajas y desventajas con respecto a maven
	* Que es una task en gradle y que ventajas me da.
	* como se manejan las dependencias de las taks y como puedo hacer que una dependa de otra.
9. Webservices
	*REST
	*SOAP wsdl 
	
b) Java

1. diferencia entre jdk y jre
	* Herramientas para debugear la jdk, jconsole, new relic.
	* como funciona el garbage collector. tipos de garbage collector.
	
2.Cuales son los conceptos de POO?
	Encapsulation
	Abstraction
	Inheritance
	Polymorphism


2.a polimorfismo

2.b clase abstracta/interfaz
	b1. como instancio una clase abstracta. 
	b2. ¿Cuántas clases puede extender una clase abstracta?  
	 ¿Cuántas interfaces? 
	
2.c encapsulamiento, definir.
	private
	public
	protected
	default

2.d clase/objeto/instancia

2.e Que 2 formas existen de reutilizar código: Herencia y Composición

3. Estructuras de datos
	*nombrar. 
	*diferencia LinkedList/arrayList 
	*set. porque el set no asegura el orden? 
	* complejidad algoritmica de add y remove en Treeset
	 - O(log n), porque la estructura de un treeset es un binary tree

3a. map
	a1. equals y hashcode
	a2. como implementar un hashcode y un equals.
	a3. sabes las diferencias entre map, hashmap, hashtable, treemap, concurrentHashMap y linkedHashmap?
	a4. Cual de estas key es mejor para un HashMap? (String, Integer, Double)
	 - String, porque String es inmutable, y java cachea el hashcode, de manera que no tiene que calcular el hashcode en cada busqueda

3b. Streams
 - Java Stream API. Filter y map son operaciones terminales o intermedias?
  > intermedias.

4. Final
	* variable.
	* método. 
	* Clase. 

4a. transient

4b. volatile

5. Constructores
	* ¿Se puede sobrecargar un constructor? 
	* ¿Se puede sobreescribir un constructor?

6 Exceptions
usamos bastante las runtime exceptions.
	* checked
	* unchecked
	* ¿El bloqué finally se ejecuta siempre?
	* ¿Se ejecuta siempre completo?
	* Que pasa si ambos bloques catch y finally tienen un return?
	 - El return del finally overridea el del catch.

7 Generics
	* ventajas
	* Como implementar una clase con generics.

8 Core questions
        * Como funciona el paquete atomic que provee java?
	- Las clases atomicas te dan una opcion lock-free thread-safe.
	  They use a combination of volatile & CAS (compare and swap) to achieve thread-safety.
          It is non-blocking in nature and thus highly usable in writing high throughput concurrent data structures
   	  Compare-and-swap (CAS) is an atomic instruction, it compares the contents of a memory location to a given value             and, only if they are the same, modifies the contents of that memory location to a given new value.
	* Why is String immutable in Java? 
	- Varias razones. Una de ellas es que java tiene un string pool en el cache de cada thread. Este string pool almacena cada string que se crea.
          Si el string fuese mutable, creo un string "Hola", y despues creo otro String "Hola", pero este segundo lo modifico (Ej: toUpperCase()), entonces 
	  tambien estaría modificando el primer string.
	- Tambien es inmutable porque tiene un uso interesante para los hashmaps. Cada vez que se crea un string se cachea su hashcode, entonces cada vez que
	  usas el string como key en un hashmap, no hace falta calcular el hashcode.
	  
	* Why char array is preferred to store passwords than a String in Java?
	- Since Strings are immutable in Java if you store the password as plain text it will be available in memory until the Garbage collector clears it and since String is used in the String pool for reusability there 	       is a pretty high chance that it will remain in memory for a long duration, which poses a security threat. 
	Since anyone who has access to memory dump can find the password in clear text and that's another reason you should always use an encrypted password than plain text. Since Strings are immutable there is no way t	   the contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his elements as blank or zero. So Storing the password in a character array clearly             mitigates security risk of stealing passwords.
	* What is a deadlock?" When two or more threads are waiting for each other to release the resource they need (lock) and get stuck for infinite time
	
	* https://www.baeldung.com/java-wait-notify
	* https://stackoverflow.com/questions/38213467/what-does-intrinsic-lock-actually-mean-for-a-java-class
	* https://jenkov.com/tutorials/java-concurrency/starvation-and-fairness.html
	* https://www.java67.com/2012/09/top-10-tough-core-java-interview-questions-answers.html
	* https://stackoverflow.com/questions/9848616/whats-the-meaning-of-an-objects-monitor-in-java-why-use-this-word
	* https://jenkov.com/tutorials/java-concurrency/synchronized.html#synchronized-blocks-instance-methods
	  - Synchronized blocks in Java are marked with the synchronized keyword. A synchronized block in Java is synchronized on some object.
            Osea, si en una clase tengo 2 metodos distintos syncrhonized, entonces no importa que sean 2 metodos distintos, solo 1 thread va a poder ejecutar uno de estos metodos a la vez.
	    Ejemplo:
	    In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time. Look at this static synchronized method example:
		public static MyStaticCounter{
		  private static int count = 0;
		  public static synchronized void add(int value){
		    count += value;
		  }
		  public static synchronized void subtract(int value){
		    count -= value;
		  }
		}
		Only one thread can execute inside any of the two add() and subtract() methods at any given time. 
		If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().
	    Also very interesting:
		When a thread enters a synchronized block it will refresh the values of all variables visible to the thread. 
		When a thread exits a synchronized block all changes to variables visible to the thread will be committed to main memory. This is similar to how the volatile keyword works.
		
 Conclusiones:
  - syncronized methods: El thread que llama al método adquiere el lock del objeto al cual pertenece el método (Conocido como lock intrinseco, ya que no cree un objeto especial para usar como lock, si no que uso
    el objeto del método como lock)
  - syncronized blocks: cuando uso esto, tengo que especificar un objeto del cual agarrar el lock. Puede ser "this" (uso el objeto actual como lock), o puede ser cualquier otro objeto.
  - usar un Lock en vez de syncronized tiene ventajas ya que el lock implementa un mecanismo de fairness (si hay varios threads esperando agarrar el lock, el lock
    va a ser agarrado por el thread que haya esperado mas tiempo, esto asegura que todos los threads eventualmente accedan al lock (fairness). Con el keyword syncrhonized, el lock del objeto
    se asigna de forma random, lo que puede causar que si varios threads estan tratando de agarrar el lock, puede que 1 o varios jamas lo agarren, o tarden demasiado.
	 
9 Threads
	9.a diferentes formas de crear threads, cual te gusta mas y porque?
		-extends thread
		-implement runnable
		-use Executors
	9.b que es un deadlock?
	9.c synchronized

10. logging
	10a. info,debug,error,fatal.
	10b. Como manejarias el logging para 20 aplicaciones en paralelo. (elk, logstash, elastic search, kivana).

11. Patrones de diseño
	10.1 que patrones de disenio conoces.
		* Template: The Template Pattern is used to defer or delegate some or all steps of an algorithm to a subclass. 
		            Common behavior can be defined in a superclass, and then specific variants are written in a subclass.
		            For example, in a super class we define a method that involves a series
		            of steps, and those steps are defined in abstract methods in the super class.
			    The subclasses will have to implement steps. 
		* Singleton: This pattern is useful when we only need a single instance of a class in the jvm.
		* Strategy: This pattern enables us to easily swap specific implementation of an algorithm at run time. Simply create an interface "Strategy" with a method like execute(), create subclasses with different
		            execute implementations, and then create a class that uses the Strategy interface. The subclasses can be swapped at runtime.
		* Builder 
		* Factory
		* Flyweight: Useful in situations where you have several inmmutable objects, and many may represent the same value. Instead of creating a new object that already exists in the heap, 
		             we re-use the existing object. Java uses the flyweight pattern, for example, in the Integer class valueOf method. The valueOf method checks the value of the given parameter, and if it is a                                precached value, the method returns the constructed instance rather than creating a new copy.

	10.2 Como se implementa singleton.
	10.3 como se implementa factory/builder

12. websocket/jetty
	* como funcionan los websockets. 
	* jetty

13.  messaging
	9.1 reactor pattern
	9.2 kafka

14. Junit/mockito/tdd
	9.1 herramientas de stress test. jmetter
	9.2 como probas tu codigo.
	9.3 defini a grandes rasgos como funciona junit.
	9.4 como usarias mockito para mockear un metodo.
	9.5 TDD

a) Herramientas
1. maven
	Conoces maven? como funciona y para que sirve?
	Como resuelvo un problema de dependencias con maven?
	Cuales son los scope de las dependencias de maven?

2. git
	2.1 Estas en rama master, creas un branch llamado 'branch1', efectuas cambios en el,como son los pasos para que tus cambios se reflejen en master.
	- git add . ; git commit -m "asd" ; git push; and then we merge to master
	2.2 Como cambio un typo en un mensaje ya commiteado. 
	- git commit --amend
	2.3 Cherry picking.
	-
	2.4 Que es un pull request?
	-
	2.5 Diferencia entre fork, branch, clone.

3. Servidor de colas externos, activemq/kafka

4. Bamboo
	*para que sirve.
5. Jira 
	* conta un poco de tu expreiencia con jira
6. jenkins

7. cucumber

8. Gradle
	* Que es y para que sirve?
	* Ventajas y desventajas con respecto a maven
	* Que es una task en gradle y que ventajas me da.
	* como se manejan las dependencias de las taks y como puedo hacer que una dependa de otra.
9. Webservices
	*REST
	*SOAP wsdl 
	
b) Java

SOLID Principles: https://www.educative.io/answers/what-are-the-solid-principles-in-java
Single Responsibility Principle	  : Each class should have a single responsability in the system.
Open-Closed Principle	          : Classes should be open for extension, but closed for modification. If I want to create a new subclass, that shouldn't impact the superclass in any way.
Liskov Substitution Principle	  : A superclass should be replaceable with its subclasses without breaking the system.
Interface Segregation Principle	  : We shouldn't force any client to implement an interface that is irrelevant to them.
Dependency Inversion Principle	  : States that we should depend on abstractions (interfaces and abstract classes) instead of concrete implementations (classes)

1. diferencia entre jdk y jre
	* Herramientas para debugear la jdk, jconsole, new relic.
	* como funciona el garbage collector. tipos de garbage collector.
	
2.Cuales son los conceptos de POO?
	Encapsulation: is a way to restrict the direct access to some components of an object
	Abstraction: is the concept that “shows” only essential attributes and “hides” unnecessary information.
	Inheritance
	Polymorphism


2.a polimorfismo

2.b clase abstracta/interfaz
	b1. como instancio una clase abstracta. 
	b2. ¿Cuántas clases puede extender una clase abstracta? Una sola
	 ¿Cuántas interfaces? infinitas
	
2.c encapsulamiento, definir.
	private
	public
	protected
	default

2.d clase/objeto/instancia

2.e Que 2 formas existen de reutilizar código: Herencia y Composición (Utlizar objetos dentro de otros objetos)

3. Estructuras de datos
	* Nombrar: Arrays, Lists, Sets, Maps, those would be the main interfaces. Then we have implementations like ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, LinkedHashMap. 
	           And we have the concurrent implementations. 
	* Diferencia LinkedList/arrayList
	  LinkedList is an ordered collection that consist of independent nodes that are pointing to each other. Every node could be at any memory position, not necessarily consecutive. ArrayList is also an ordered collection, but its implemented with an array data structure, meaning its data is stored in consecutive memory blocks.
	This two different implementations have pros and cons when it comes to performance and memory usage.
	
	Random Access Search: ArrayList has direct references to every element in the list, so it can get the n-th element in constant time. 
                              LinkedList has to traverse the list from the beginning to get to the n-th element.
	Delete: ArrayList is slower because once the item is removed, it has to shift the right side of the array to the left. (Unless its removing the last item) O(1) if removes last item, else O(n)
		For LinkedList, If the deletion is done using the ListIterator.remove() API, LinkedList just has to manipulate a couple of references; if the deletion is done by value or by index, LinkedList has to potentially scan the entire list first to find the element(s) to be deleted.
	Etc..
	For time complexity: https://www.w3schools.blog/arraylist-linkedlist-vector-java


	*Set. porque el set no asegura el orden?  Porque a la interfaz Set solo la interesa asegurar unicidad, no orden.
		Para un Set ordenado, hay subinterfaces de Set como SortedSet, con implementaciones como TreeSet y LinkedHashSet.
	     Performance and Speed : First difference between comes in terms of speed. HashSet is fastest, LinkedHashSet is second on performance or almost similar to HashSet but TreeSet is bit slower because of 
             sorting operation it needs to perform on each insertion. TreeSet provides guaranteed O(log(n)) time for common operations like add, remove and contains, while HashSet and LinkedHashSet offer constant time 
             performance e.g. O(1) for add, contains and remove given hash function uniformly distribute elements in bucket.
             Ordering : HashSet does not maintain any order while LinkedHashSet maintains insertion order of elements much like List interface and TreeSet maintains sorting order or elements.

3a. map
	a1. equals y hashcode:
		If two objects are equal according to equals() method, then their hash code must be same. 
		If two objects are unequal according to equals() method, their hash code are not required to be different.
	a2. como implementar un hashcode y un equals.
	a3. sabes las diferencias entre map, hashmap, hashtable, treemap, concurrentHashMap y linkedHashmap?
	a4. Cual de estas key es mejor para un HashMap? (String, Integer, Double)
	 - String, porque String es inmutable, y java cachea el hashcode, de manera que no tiene que calcular el hashcode en cada busqueda

3b. Streams
 - Java Stream API. Filter y map son operaciones terminales o intermedias?
  > Intermedias: filter, map, distinct, sorted, limit. 
  > Terminal(End of stream): forEach, collect, reduce, count, min, max, anyMatch, allMatch, noneMatch.

4. Final
	* variable: its memory reference cannot be modified
	* método: cannot be overriden
	* Clase: cannot be extended

5. Constructores
	* ¿Se puede sobrecargar un constructor? Si, podes tener varios constructores en una clase con diferentes firmas.
	* ¿Se puede sobreescribir un constructor? No, si tenes una subclase, no podes sobreescribir el constructor de la clase padre. El constructor de la clase padre siempre se llama

6 Exceptions: https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/
	* Object -> Throwable -> Error: Indicates a problem that the application can not recover from. (Like OOM)
			      -> Exception: Indicates a problem that the application could recover from.	
	* Checked Exception -> Is caught at compile time
	* Unchecked Exception-> Its caught at runtime
	* ¿El bloqué finally se ejecuta siempre? Si.
	* ¿Se ejecuta siempre completo? Depende. si ocurre una exception en el bloque finally, entonces no. Si no, si.
	* Que pasa si ambos bloques catch y finally tienen un return? El return del finally overridea el del catch.

7 Generics
	* ventajas
	* Como implementar una clase con generics.

8 Core questions
 --- Memory Management ---
Whenever an object is created, it's always stored in the Heap space and stack memory contains the reference to it. 
Stack memory only contains local primitive variables and reference variables to objects in heap space.
https://www.baeldung.com/java-stack-heap
Poner tambien lo del GC y eden space y todo eso. donde se asignan las variables primitivas y donde los objetos (stack vs heap)

        * Como funciona el paquete atomic que provee java?
	- Las clases atomicas te dan una opcion lock-free thread-safe.
	  They use a combination of volatile & CAS (compare and swap) to achieve thread-safety.
          It is non-blocking in nature and used concurrent data structures.
   	  Compare-and-swap (CAS) is an atomic instruction, it compares the contents of a memory location to a given value and, only if they are the same, 
          modifies the contents of that memory location to a given new value.
	* Serialization in Java
	- Serialization is the conversion of the state of an object into a byte stream. The object has to implement Serializable interface.
	  static variables, since they belong to the class and not the object, are not serialized. There are a few more caveats related with inheritance.
	* transient keyword: transient keyword is used along with instance variables to exclude them from the serialization process.
        * volatile keyword:  volatile keyword can be used in variables to indicate the compiler and JVM to always read its value from the main memory instead of the thread heap or stack. 
	  This way, in multithreading scenarios, you make the variable visible to all threads.
	  Good reading: https://stackoverflow.com/questions/62914811/java-multi-threading-why-do-we-need-to-look-into-main-memoryram-if-we-have
	* Why is String immutable in Java? 
	- Varias razones. Una de ellas es que java tiene un string pool en el cache de cada thread. Este string pool almacena cada string que se crea.
          Si el string fuese mutable, creo un string "Hola", y despues creo otro String "Hola", pero este segundo lo modifico (Ej: toUpperCase()), entonces 
	  tambien estaría modificando el primer string.
	- Tambien es inmutable porque tiene un uso interesante para los hashmaps. Cada vez que se crea un string se cachea su hashcode, entonces cada vez que
	  usas el string como key en un hashmap, no hace falta calcular el hashcode.
	  
	* Why char array is preferred to store passwords than a String in Java?
	- Since Strings are immutable in Java if you store the password as plain text it will be available in memory until the Garbage collector clears it and since String is used in the String pool for reusability there 	       is a pretty high chance that it will remain in memory for a long duration, which poses a security threat. 
	Since anyone who has access to memory dump can find the password in clear text and that's another reason you should always use an encrypted password than plain text. Since Strings are immutable there is no way t	   the contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his elements as blank or zero. So Storing the password in a character array clearly             mitigates security risk of stealing passwords.
	* What is a deadlock?" When two or more threads are waiting for each other to release the resource they need (lock) and get stuck for infinite time
	
	* https://www.baeldung.com/java-wait-notify
	* https://stackoverflow.com/questions/38213467/what-does-intrinsic-lock-actually-mean-for-a-java-class
	* https://jenkov.com/tutorials/java-concurrency/starvation-and-fairness.html
	* https://www.java67.com/2012/09/top-10-tough-core-java-interview-questions-answers.html
	* https://stackoverflow.com/questions/9848616/whats-the-meaning-of-an-objects-monitor-in-java-why-use-this-word
	* https://jenkov.com/tutorials/java-concurrency/synchronized.html#synchronized-blocks-instance-methods
	  - Synchronized blocks in Java are marked with the synchronized keyword. A synchronized block in Java is synchronized on some object.
            Osea, si en una clase tengo 2 metodos distintos syncrhonized, entonces no importa que sean 2 metodos distintos, solo 1 thread va a poder ejecutar uno de estos metodos a la vez.
	    Ejemplo:
	    In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time. Look at this static synchronized method example:
		public static MyStaticCounter{
		  private static int count = 0;
		  public static synchronized void add(int value){
		    count += value;
		  }
		  public static synchronized void subtract(int value){
		    count -= value;
		  }
		}
		Only one thread can execute inside any of the two add() and subtract() methods at any given time. 
		If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().
	    Also very interesting:
		When a thread enters a synchronized block it will refresh the values of all variables visible to the thread. 
		When a thread exits a synchronized block all changes to variables visible to the thread will be committed to main memory. This is similar to how the volatile keyword works.
		
 Conclusiones:
  - syncronized methods: El thread que llama al método adquiere el lock del objeto al cual pertenece el método (Conocido como lock intrinseco, ya que no cree un objeto especial para usar como lock, si no que uso
    el objeto del método como lock)
  - syncronized blocks: cuando uso esto, tengo que especificar un objeto del cual agarrar el lock. Puede ser "this" (uso el objeto actual como lock), o puede ser cualquier otro objeto.
  - usar un Lock en vez de syncronized tiene ventajas ya que el lock implementa un mecanismo de fairness (si hay varios threads esperando agarrar el lock, el lock
    va a ser agarrado por el thread que haya esperado mas tiempo, esto asegura que todos los threads eventualmente accedan al lock (fairness). Con el keyword syncrhonized, el lock del objeto
    se asigna de forma random, lo que puede causar que si varios threads estan tratando de agarrar el lock, puede que 1 o varios jamas lo agarren, o tarden demasiado.
	 
9 Threads
	9.a diferentes formas de crear threads, cual te gusta mas y porque?
		-extends thread
		-implement runnable
		-use Executors
	9.b que es un deadlock?
	9.c synchronized

10. logging
	10a. info,debug,error,fatal.
	10b. Como manejarias el logging para 20 aplicaciones en paralelo. (elk, logstash, elastic search, kivana).

11. Patrones de diseño
	10.1 que patrones de disenio conoces.
		* Template: The Template Pattern is used to defer or delegate some or all steps of an algorithm to a subclass. 
		            Common behavior can be defined in a superclass, and then specific variants are written in a subclass.
		            For example, in a super class we define a method that involves a series
		            of steps, and those steps are defined in abstract methods in the super class.
			    The subclasses will have to implement steps. 
		* Singleton: This pattern is useful when we only need a single instance of a class in the jvm.
		* Strategy: This pattern enables us to easily swap specific implementation of an algorithm at run time. Simply create an interface "Strategy" with a method like execute(), create subclasses with different
		            execute implementations, and then create a class that uses the Strategy interface. The subclasses can be swapped at runtime.
		* Builder 
		* Factory
		* Flyweight: Useful in situations where you have several inmmutable objects, and many may represent the same value. Instead of creating a new object that already exists in the heap, 
		             we re-use the existing object. Java uses the flyweight pattern, for example, in the Integer class valueOf method. The valueOf method checks the value of the given parameter, and if it is a                                precached value, the method returns the constructed instance rather than creating a new copy.

	10.2 Como se implementa singleton.
	10.3 como se implementa factory/builder

12. websocket/jetty
	* como funcionan los websockets. 
	* jetty

13.  messaging
	9.1 reactor pattern
	9.2 kafka

14. Junit/mockito/tdd
	9.1 herramientas de stress test. jmetter
	9.2 como probas tu codigo.
	9.3 defini a grandes rasgos como funciona junit.
	9.4 como usarias mockito para mockear un metodo.
	9.5 TDD

15. Patrones de Diseño para arquitectura de  microservicios
Sources: 
https://www.tutorialspoint.com/microservices_design_patterns/microservices_design_patterns_proxy.htm
https://medium.com/@madhukaudantha/microservice-architecture-and-design-patterns-for-microservices-e0e5013fd58a

Integration Patterns

(A) Aggregator pattern: Its helpful when a consumer needs data from many different microservices. Instead of making the consumer client to call many microservices, it could call an aggregator microservice that will collect the required data from the different microservices, aggregate the data and build a final response to the consumer. This can be done in two ways:
 - A composite microservice will make calls to all the required microservices, consolidate the data, and transform the data before responding to the client.
 - An API Gateway can also partition the request to multiple microservices and aggregate the data before sending it to the consumer.
If any business logic needs to be applied, the composite microservice is recommended, otherwise, the API Gateway is the established solution.

(B) API Gateway: When there are many microservices in the system, the API Gateway works as the single point of entry for any microservice call. It can also aggregate the results, or take care the authentication and authorization. It can also have features like rate limiting, api monitoring, etc.
The difference with the Aggregator pattern is that API Gateway is always at the gate, its the entry point to the system, and its only one, while the aggregegator microservice could be somewhere in the middle layer.

(C) Proxy Pattern: Its the same as the API Gateway but the only thing that it does is to re-route the requests to the desired microservice.

(D) Chained Pattern: It has a single entry point, lets say microservice A. Microservice A will call microservice B, and B will call C, and so on in a manner of syncrhonous calls to get the task done. This is slow, but its secure given we have just one entry point.

(E) Is a hybrid of chain and aggregator pattern. Service A -> Service C -> Service D
                                                           -> Service B

Service A is acting like an aggregator and it is branching out into two branches. One branch contains a single autonomous service (Service B) and the other branch contains a chain of services (Service D is accessible from Service C). This type of design is useful when a large monolithic application is needed to be converted into an application with microservice type of architecture.

Database Patterns

(A) The Database-per-Service Pattern: In order to keep the loose coupling between services, each microservice should have its own private database. Separating databases per app has the advantage that we can pick the best optimized database for each microservice.

(B) Command Query Responsibility Segregation (CQRS): This pattern is meant to separate the read(query) and write(command) logic of our applications in regards to the database. This is sometimes a good idea when we have a database with a lot of reads and writes that are producing a lock contention, maybe because the read queries involve the join of multiple tables. 

There are many ways to implement this. 
In a single database (Having tables for writes and materialized views for reads)
In two databases: One for writing and another for reading.
Etc.

The event sourcing pattern is generally used along with it to create events for any data change. Materialized views are kept updated by subscribing to the stream of events.

Materialized view: A materialized view is a database object that contains the results of a query. For example, it may be a local copy of data located remotely, or may be a subset of the rows and/or columns of a table or join. The query result is cached as a concrete ("materialized") table (rather than a view as such) that may be updated from the original base tables from time to time. This enables much more efficient access, at the cost of extra storage and of some data being potentially out-of-date. 

(C) Event sourcing: This pattern involves sending a continuous stream of messages to some event storage. Each message describes an event in the system. Examples include: A write to the database, request to a web server, or logging activity. Applications then query the event store in a way that suits their needs. The event store becomes our primary source of truth

Great web for CQRS and Event sourcing: https://www.baeldung.com/cqrs-event-sourcing-java

When to use Event sourcing? 
- If the business requires it, for audit purposes
- When the ability to re-build the system state at certain point on time is needed
- Good for debugging.
- ETC.

Observability Patterns

(A) Log Aggregation
Consider a use case where an application consists of multiple services. Each service instance generates a log file in a standardized format. We need a centralized logging service that aggregates logs from each service instance.

(B) Performance Metrics
When a metrics service is required to gather statistics about individual operations. It should aggregate the metrics of an application service, which provides reporting and alerting.
There are two models for aggregating metrics:
Push — the service pushes metrics to the metrics service e.g. NewRelic, AppDynamics
Pull — the metrics services pulls metrics from the service e.g. Prometheus


Cross-Cutting Concern Patterns

(A) Service Discovery Pattern

When microservices come into the picture, we need to address a few issues in terms of calling services.
With container technology, IP addresses are dynamically allocated to the service instances. Every time the address changes, a consumer service can break and need manual changes.
Each service URL has to be remembered by the consumer and become tightly coupled.
A service registry needs to be created which will keep the metadata of each producer service and specification for each. A service instance should register to the registry when starting and should de-register when shutting down. There are two types of service discovery

(B) Circuit Breaker Pattern

A service generally calls other services to retrieve data, and there is the chance that the downstream service may be down. There are two problems with this: first, the request will keep going to the down service, exhausting network resources, and slowing performance. Second, the user experience will be bad and unpredictable.

The consumer should invoke a remote service via a proxy that behaves in a similar fashion to an electrical circuit breaker. When the number of consecutive failures crosses a threshold, the circuit breaker trips, and for the duration of a timeout period, all attempts to invoke the remote service will fail immediately. After the timeout expires the circuit breaker allows a limited number of test requests to pass through. If those requests succeed, the circuit breaker resumes normal operation. Otherwise, if there is a failure, the timeout period begins again.



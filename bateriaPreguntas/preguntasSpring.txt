https://www.youtube.com/watch?v=UgX5lgv4uVM

Spring is a framework focused on the inversion of control principle. To achieve this it uses the dependency Injection pattern.
Because of this, it makes it easy to develop loosely coupled applications. It makes applications testable.

2.- listame caracteristicas de spring
	a) contenedor
	b) framework-mvc
	c) inversion de control
		c.1) que es la inyeccion de dependencias?
		c.2) Liste algunos tipos de inyeccion de dependencias.
	d) transacciones
		d.1) en que capa se manejan las transacciones?
	e) programacion orientada a aspectos
	f) manejo de excepciones jdbc
		

Spring Core
	Inversion of control 
        Application Context 
        Beans 

Spring MVC
	Models
	Annotations
	CRUD REST API
	CDRS
	Data Validation

Spring Data
	- JDBC
	- ...

Spring Boot
	Spring based applications have a lot of configuration. When we use Spring MVC, we need to configure component scan, dispatcher servlet, a view resolver, web jars(for delivering static content) among other things. 	        When we use Hibernate/JPA, we would need to configure a datasource, an entity manager factory, a transaction manager among a host of other things. 
	Spring Boot can auto configure some beans automatically
	
	Spring boot provides:
	Starters - convenient dependencies that package everything we need for certain scenarios
	Auto config
	Production ready - Actuator dependency provides production ready features: Endpoints for health check, beans, etc
	                                                                           Observability - Logging, metrics, tracing

Spring MVC 
	Provides a decoupled way of developing web applications, separating the model, the view and the controller(a.k.a dispatcher servlet)


Annotation questions:
	- Q: Let's say I have a class that I don't own because its in an external library, how do I inject an instance of that class into the ApplicationContext?
	  A: We create a class with the @Configuration annotation. Inside that class, we create a method that returns an instance of the class we want to inject, and we mark the method
             with the @Bean annotation. @Bean indicates that a method produces a bean that will be managed by the Spring Container. The name of the bean wil be the method name

	- Q: What does @Controller and @RestController do?
	  A: @Controller is used to create web controllers that return views, which is further resolved by view resolver, while @RestController is used to create web services that return JSON or XML data

	- Q: What does @RequestMapping do?
	  A: It tells Spring whats the path to arrive to the current controller.

	- Q: What does @GetMapping do?
	  A: Its a method annotation that tells spring to call the current method for GET requests for a certain path.

	- Q: What does @Repository do?
	  A: It tells Spring that the class provides a mechanism for storage, retrieval, search, update and delete operation on objects.

	- Q: What does @Autowired do?
	  A: It tells Spring to assign a variable with an instance that is living in the application context.
	     It is not always needed to write this annotation. For example, if a class has a constructor with just 1 argument, Spring will autowire that argument without the need for the annotation.

	- Q: What does @PostConstruct do?
	  A: It tells spring that the current method has to be called after dependency injection is done. Usually used for initialization.

	- Q: What does @PathVariable do?
	  A: Tells spring that the argument value has to be taken from the Mapping Path
		@GetMapping("/{id}")
		public Integer findById(@PathVariable Integer id) {
                	...
		}

	- Q: What does @ResponseStatus do?
	  A: Sets the response HTTP code of a controller method. The status will be set if no exception is thrown.

	- Q: What does @RequestBody do?
	  A: Maps the HttpRequest body to a java object, enabling automatic deserialization. In the example, the LoginForm object is created
		@PostMapping("/request")
		public ResponseEntity postController(@RequestBody LoginForm loginForm) {
		    ....
		}
	  Q: How do we validate that the given LoginForm is ok?
          A: We use a validator. First, we tell spring using the @Valid annotation that it has to validate the LoginForm
		@PostMapping("/request")
		public ResponseEntity postController(@Valid @RequestBody LoginForm loginForm) {
		    ....
		}
  	     Then, in the LoginForm class, we can annotate each field to define what validations we want. Like @NotNull, @NotBlank, etc.


JDBC Questions

	- Q: How can I make Spring run a query or sql script on every startup?
	  A: We can do this programatically or using a .sql file.
		SQL FILE: Spring JDBC has a DataSource initializer feature enabled by default. It scans the root classpath looking for the files schema.sql and data.sql. 
			  In addition Spring Boot will load the schema-${platform}.sql and data-${platform}.sql files (if present).

	- Q: What does the JDBCTemplate interface gives us? Is it part of Spring Data?
	  A: JDBCTemplate offers an interface to talk to the database. We still have to write the Queries as usual, and the interface asks for a RowMapper method, that Spring will use
	     to create an Object for every row in the result set.
	     This is the first layer of abstraction that Spring provides when it comes to the DB. 
	     JDBCTemploate is not part of Spring Data. Spring data offers more layers of abstraction (JDBCTemplate is not the same as Spring Data JDBC), where we don't have to write any queries
	     or row mappers.

	- Q: Spring Data JDBC vs Spring Data JPA?
	  A: Spring Data JPA and Spring Data JDBC use Spring Data Commons as a base library. Both share the same abstractions; the most important one is Repository. 
             In Spring Data JPA, repositories allow us to use derived methods instead of queries. Such methods transparently convert their invocations to queries using a JPA implementation. 
             In Spring Data JDBC, method invocations are transformed into pure SQL and executed via JDBC.
	     Spring Data JDBC is very similar to Spring Data JPA in terms of API. However, JPA provides several useful features that are not present in Spring Data JDBC:

             @*ToOne associations allow us to create bidirectional references between entities.
	     Automatic ID generation prevents us from manually selecting IDs from sequences or caring about IDENTITY datatype support in an RDBMS.
             Batch operations. Hibernate groups similar operations into batches automatically. It helps when an application deals with massive insert operations.
             L1 Cache keeps entities used in one transaction in memory. It allows us not to fetch the same data twice in two services if executed in the same transaction.
             Etc.

	
